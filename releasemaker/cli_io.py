# -*- encoding: utf-8 -*-
from __future__ import unicode_literals
import csv
from datetime import datetime

from releasemaker.api import GitHubRepo
from releasemaker.exceptions import MergeFailure
from releasemaker.git import GitInterface


def make_release():
    """
    Performs necessary user interaction to make a new release branch.

    :param github_repo:
            A `GitHubRepo` object.
    :param repo_dir
            Absolute path to a local Git repository that matches the GitHub remote.
    """
    api_token = ask_api_token()
    git_interface = GitInterface.create_from_cwd()
    repo_owner, repo_name = git_interface.infer_repo_details()

    print 'Creating a release for repository %s.' % repo_name

    # Don't build releases when local changes could interfere
    if git_interface.tracked_files_changed():
        print 'You seem to have changes in tracked files. To avoid issues, the release build will be aborted.'
        return

    # Make sure we're up-to-date
    git_interface.fetch_all()

    # Make a clean release branch
    target_branch = ask_target_branch()
    git_interface.create_release_branch(target_branch)
    print 'Created branch %s.' % target_branch

    # Gather list of pull requests
    github_repo = GitHubRepo(repo_owner, repo_name, api_token)
    filter_labels = ask_filter_labels()
    print 'Fetching open pull requests on GitHub (label filter: %s)...' % ', '.join(filter_labels)
    prs = github_repo.get_open_pull_requests(required_labels=filter_labels)

    # Iterate over the release branches one by one and see what we want to merge.
    included_prs = []
    for pr in prs:
        include_pr = ask_include_pr(pr)
        if include_pr is True:
            included_prs.append(pr)
            try:
                git_interface.merge_branch(pr.branch_name)
            except MergeFailure:
                should_continue = ask_yesno_question('Woah there, champ... Smells like a merge conflict.'
                                                     ' Continue building the release branch?', False)
                if should_continue is False:
                    print 'Aborting mission.'
                    return

    # Export list of merged branches to CSV if requested.
    export_csv = ask_export_csv(target_branch)
    if export_csv:
        with open('%s.csv' % target_branch, 'wb') as csv_file:
            csv_writer = csv.writer(csv_file)
            for pr in included_prs:
                csv_writer.writerow([pr.pr_id, pr.branch_name])


def ask_export_csv(target_branch):
    """
    Returns answer to the question whether the user would like a CSV dump with that. One-liner was extracted to
    facilitate unit testing.
    """
    return ask_yesno_question(
        'All done! Should we write a list of included branches to %s.csv?' % target_branch, False
    )


def ask_api_token():
    """
    Ask to enter one of these: https://github.com/blog/1509-personal-api-tokens. This one-liner is a separate method to
    faciliate unit testing.
    """
    return raw_input('What is your personal API token for GitHub? ')


def ask_yesno_question(question, default_answer):
    """Pose a yes/no question to the user. Default answer will be taken upon empty input."""

    # These help us map raw input to a boolean value (and do the reverse as well)
    answer_mapping = {
        True: ['y', 'yes'],
        False: ['n', 'no'],
    }
    boolean_mapping = {}
    for bool_key, answers_list in answer_mapping.iteritems():
        for answer in answers_list:
            boolean_mapping[answer] = bool_key

    # Ask the question until we get a valid answer
    while True:
        answer = raw_input('%s [default: %s] ' % (question, answer_mapping[default_answer][0]))
        if not answer:
            return default_answer

        case_insensitive_answer = answer.lower()
        if case_insensitive_answer in boolean_mapping.keys():
            return boolean_mapping[case_insensitive_answer]


def ask_include_pr(pr):
    """Ask whether a given pull request needs to be included in a release."""
    print ''
    uc_multiline = pr.unicode_multiline()
    for line in uc_multiline:
        print line
    print ''
    return ask_yesno_question('Do you want to include this branch in the release?', False)


def ask_target_branch():
    """Ask what the branch's name should be, defaulting to an autogenerated name."""
    default_target_branch = 'release-%s' % datetime.now().strftime('%Y%m%d-%H%M%S')
    target_branch = raw_input('What will be the name of the release branch? [default: %s] ' % default_target_branch)
    if not target_branch:
        target_branch = default_target_branch
    return target_branch


def ask_filter_labels():
    """Ask enter a list of pull request labels to filter on."""
    filter_label = raw_input('Filter by label? [default: no filter] ')
    filter_labels = []
    if filter_label:
        filter_labels = [filter_label]
    return filter_labels
